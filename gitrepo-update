#!/usr/bin/perl

# --------------------------------------------
#
# Small utility program to be able to push
# commits to multiple remote origins with git.
#
# ~331uw13
# --------------------------------------------



use strict;
use warnings;
use feature qw(switch);

use Config::Tiny;

our $version = "0.01";
our $home = $ENV{"HOME"};
our $cfgdir = "$home/.gitrepo-update";
our $basecfg = "$cfgdir/basecfg.ini";

our $prefix_prog_name = "gitrepo-update";
our $prefix = "\033[1;36m$prefix_prog_name\033[90m:\033[0m ";
our $prefix_err = "\033[1;31m$prefix_prog_name\033[90m:\033[0m ";
our $prefix_indent = ' ' x (length($prefix_prog_name)+2);

sub print_help {
    print(
        "\n".
        "* -c                     ; Show current config number.\n".
        "* -l                     ; List all remote origins in current config.\n".
        "* -a [url]               ; Add new remote origin to current config.\n".
        "  -r [name]              ; Delete remote origin from current config.\n".
        "\n".
        "* -n [name]              ; Create new config.\n".
        "* -lc                    ; List all saved configs.\n".
        "  -rc [name]             ; Delete config.\n".
        "* -sc [name]             ; Switch config.\n".
        "\n".
        "  push-commit [message]  ; Create commit and push to all remote origins in current config.\n".
        "\n".
        "\033[90mversion $version\033[0m\n"
    );
    exit();
}

sub create_cfgdir {
    mkdir $cfgdir;
    open(FH, '>', $basecfg) or die $!;
    print FH "[base]\n".
    "current_config=<none>\n".
    "avail_configs[]=\n";
    close(FH);
}

sub get_current_config {
    my $cfg = Config::Tiny->read($basecfg);
    
    return $cfg->{base}->{current_config};
}

sub get_avail_configs {
    my $cfg = Config::Tiny->read($basecfg); 
    my $arr = $cfg->{base}->{avail_configs};
    return @$arr;
}

sub get_config_remote_origins {
    my $cfg = Config::Tiny->read("$cfgdir/$_[0].ini"); 
    my $arr = $cfg->{config}->{remote_origins};
    return @$arr;
}

sub create_config {
    my $cfgname = $_[0];
    if(-e "$cfgdir/$cfgname.ini") {
        print("$prefix_err Config with name \"$cfgname\" already exists.\n");
        exit();
    }
 
    open(FH, '>', "$cfgdir/$cfgname.ini") or die $!;
    print FH "[config]\n".
    "remote_origins[]=\n";
    close(FH);
   
    my $cfg = Config::Tiny->read($basecfg); 

    my @configs = get_avail_configs();
    foreach my $i (@configs) {
        if($i eq $cfgname) {
            print("$prefix_err Config with name \"$cfgname\" already exists.\n");
            exit();
        }
    }
    my $num_configs = scalar(@configs);
    
    $cfg->{base}->{avail_configs}->[$num_configs] = $cfgname;
    $cfg->write($basecfg);
}

sub switch_config {
    my $cfgname = $_[0];
    my $cfg = Config::Tiny->read($basecfg); 

    $cfg->{base}->{current_config} = $cfgname;
    $cfg->write($basecfg);
}

sub add_remote_origin {
    my $curr_config = get_current_config();
    if($curr_config eq "<none>") {
        print("$prefix_err Cant add new remote origin to config, ".
            "because no config is selected.\n");
        return;
    }
   
    my @remote_origins = get_config_remote_origins($curr_config);
    my $num_origins = scalar(@remote_origins);
    my $cfg_file = "$cfgdir/$curr_config.ini";
    my $cfg = Config::Tiny->read($cfg_file);

    $cfg->{config}->{remote_origins}->[$num_origins] = $_[0];

    $cfg->write($cfg_file);
}

sub process_flag {
    my $flag = $_[0];
    my $index = $_[1];

    given($flag) {
        when("-c") {
            print("$prefix Currently selected config = ". get_current_config() ."\n");
            return 0;
        }
        when("-a") {
            if(!defined($ARGV[$index+1])) {
                print_help();
            }
            add_remote_origin($ARGV[$index+1]);
            return 1;
        }
        when("-l") {
            my $curr_config = get_current_config();
            if($curr_config eq "<none>") {
                print("$prefix_err Cant read remote origins in config, ".
                    "because no config is selected.\n");
                return 0;
            }
            my @remote_origins = get_config_remote_origins($curr_config);
            print("$prefix Remote origins in config '$curr_config':\n");
            for my $i (0 .. $#remote_origins) {
                if(length($remote_origins[$i]) > 0) {
                    print("$prefix_indent ($i) - '$remote_origins[$i]'\n");
                }
            }
            return 0;
        }
        when("-lc") {
            my @configs = get_avail_configs();
            print("$prefix Available configs:\n");
            for my $i (0 .. $#configs) {
                if(length($configs[$i]) > 0) {
                    print("$prefix_indent ($i) - '$configs[$i]'\n");
                }
            }
            return 0;
        }
        when("-sc") {
            if(!defined($ARGV[$index+1])) {
                print_help();
            }
            switch_config($ARGV[$index+1]);
            return 1;
        }
        when("-n") {
            if(!defined($ARGV[$index+1])) {
                print_help();
            }
            create_config($ARGV[$index+1]);
            return 1;
        }
        default {
            print("$prefix_err Unknown action flag: '$flag'\n");
            return 0;
        }
    }

    return 0;
}

sub main {
    if(! -d $cfgdir) {
        create_cfgdir();
    }

    if(scalar(@ARGV) <= 0) {
        print("$prefix_err No action selected.\n");
        print_help();
    }

    my $num_args = scalar(@ARGV);
    
    for(my $i = 0; $i < $num_args; ) {
        my $i_skip = process_flag($ARGV[$i], $i);

        $i += 1 + $i_skip;
    }

}


main();
